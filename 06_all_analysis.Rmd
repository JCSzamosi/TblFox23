Analysis of Fox2/3 KO Experiment
================================
## To Do

* Fix the orientation of the WT/KO comparison so WT is default
* Remove the genes/exons for which there is not enough info to analyze from 
the `goseq` analysis

## Setup

```{r}
library('DEXSeq')
library('Rsubread')
library(tidyverse)
library(goseq)
setwd('~/Projects/Clients/Turnbull/CRISPR3_Take2/')
```

## Import data

```{r}
# Set up file locations and sample names
dirs = list.dirs('results/05_map2',recursive = FALSE)
dirs
samps = gsub('results/05_map2/', '', dirs, fixed = TRUE)
samps

# Set up the Gene ID lookup table (csv was produced manually from the GTF file)
gene_id_lookup = read.csv('refs/unique_gene_ids.csv')
dim(gene_id_lookup)
head(gene_id_lookup)
n_distinct(gene_id_lookup$gene_id)
n_distinct(gene_id_lookup$GeneID)
gene_id_v = gene_id_lookup$GeneID
names(gene_id_v) = gene_id_lookup$gene_id
duplicate_geneIDs = (gene_id_lookup 
                     %>% count(GeneID) 
                     %>% filter(n > 1) 
                     %>% left_join(gene_id_lookup))


# Pre-make the data frames to fill all the numbers in
exon_counts = matrix(NA, ncol = length(samps), nrow = 1520722)
colnames(exon_counts) = samps
head(exon_counts)

# Define the gtf and genome files
gtf = '~/Disk2/CommonData/ReferenceGenomes/Mouse/GRCm39/ncbi-genomes-2022-03-04/GCF_000001635.27_GRCm39_genomic.gtf'
genome = '~/Disk2/CommonData/ReferenceGenomes/Mouse/GRCm39/ncbi-genomes-2022-03-04/GCF_000001635.27_GRCm39_genomic.fna'

# Bring in the sample data and clean it up
samdat = read.csv('data/sample_data/samdat.csv', row.names = 1)
samdat
samdat = (samdat
          %>% mutate(Treatment = factor(Treatment, levels = c('WT','KO'))))
samps = rownames(samdat)
samps = gsub('-','_',samps,fixed = TRUE)
rownames(samdat) = samps
```


## Feature Counts

### Setup
```{r}
# Define a function to count features at the exon and gene level
call_fc = function(bamf, gtf, genome, useMF = FALSE){
    fc = Rsubread::featureCounts(bamf, 
                       annot.ext = gtf, isGTFAnnotationFile = TRUE,
                       GTF.featureType = 'exon', 
                       GTF.attrType = 'gene_id',
                       GTF.attrType.extra = 'exon_number', 
                       allowMultiOverlap = TRUE,
                       strandSpecific = 2,
                       genome = genome,
                       isPairedEnd = TRUE,
                       countReadPairs = FALSE,
                       requireBothEndsMapped = TRUE,
                       countChimericFragments = FALSE,
                       nthreads = 10,
                       verbose = TRUE,
                       useMetaFeatures = useMF)
    return(fc)
}
```

### Run on the first sample

I run this once and then keep it stored because it takes a long time
to run

```{r}
# # Call it all once to set up the structure
# samp = samps[1]
# dr = dirs[1]
# bamf = paste(dr, 'Aligned.sortedByCoord.out.bam', sep = '/')
# fc = call_fc(bamf, gtf, genome)
# fc_genes = call_fc(bamf, gtf, genome, TRUE)
# stats = (fc$stat
#          %>% data.frame()
#          %>% column_to_rownames('Status'))
# colnames(stats) = samp
# exon_counts[,samp] = fc$counts
# 
# fc_lst = list()
# fc_lst[[samp]] = fc
# fc_lst_gene = list()
# fc_lst_gene[[samp]] = fc_genes
```

### Run on the rest of the samples

I run this once and then keep it stored because it takes a long time
to run

```{r}
# # Call the same thing on all the mapping files
# 
# for (i in 2:length(dirs)){
#     samp = samps[i]
#     dr = dirs[i]
#     bamf = paste(dr, 'Aligned.sortedByCoord.out.bam', sep = '/')
#     fc = call_fc(bamf, gtf, genome)
#     exon_counts[,samp] = fc$counts
#     stats[fc$stat$Status,samp] = fc$stat$Aligned.sortedByCoord.out.bam
#     fc_lst[[samp]] = fc
#     fc_genes = call_fc(bamf, gtf, genome, useMF = TRUE)
#     fc_lst_gene[[samp]] = fc_genes
# }
# 
# # get gene lengths
# gene_lens = select(fc_genes$annotation, GeneID, Length)
# 
# save(list = c('exon_counts', 'stats', 'fc_lst', 'fc_lst_gene', 'gene_lens'), 
#      file = 'RData/feature_counts.RData')
load('RData/feature_counts.RData')
head(exon_counts)
```


### Parse the feature counts

```{r}
# Get the gene and exon information for all the files
# chk = vector(length = length(fc_lst) -1)
# for (i in 2:length(fc_lst)){
#     chk[i-1] = all_equal(fc_lst[[1]]$annotation, fc_lst[[i]]$annotation)
# }
annot = fc_lst[[1]]$annotation
head(annot)

# Make sure exon numbers are unique and in a format DEXSeq can use
annot = (annot
         %>% data.frame()
         %>% group_by(GeneID)
         %>% mutate(exon_unique = as.character(1:length(GeneID)))
         %>% data.frame())
head(annot)
head(rownames(exon_counts))

# Make sure sample names are correctly formatted
samps = colnames(exon_counts)
samps = gsub('-','_',samps, fixed = TRUE)
colnames(exon_counts) = samps
```

Check if the two pairs of genes with duplicate IDs have any read
counts associated with them

```{r}
# Do the genes with duplicate IDs have any counts associated with them?
rowSums(exon_counts[annot$GeneID %in% duplicate_geneIDs$gene_id,])

# They do. In some cases, it's a pretty big number
dup_cts = exon_counts[annot$GeneID %in% duplicate_geneIDs$gene_id,] 
rownames(dup_cts) = annot$GeneID[annot$GeneID %in% duplicate_geneIDs$gene_id]
dup_cts

annot %>% filter(GeneID %in% duplicate_geneIDs$gene_id)
```

These genes can't be merged because they are different, but they have the same
GeneID. They will be included in the DEXSeq analysis, but excluded from the
goseq analysis.

## Differential Exon Usage

### Naive cells

#### DEXSeq

I run this once and then keep it stored because it takes a long time to run

```{r}
# Run DEXSeq on undifferentiated samples
head(exon_counts)

samdat_undif = filter(samdat, Differentiation == 'Naive')
exon_ct_undif = exon_counts[,rownames(samdat_undif)]
samdat_undif
head(exon_ct_undif)
# 
# dxd = DEXSeqDataSet(exon_ct_undif, samdat_undif,
#                     design = ~sample + exon + exon:Treatment,
#                     featureID = annot$exon_unique,
#                     groupID = annot$GeneID)
# dxd = estimateSizeFactors(dxd, locfunc = genefilter::shorth)
# dxd = estimateDispersions(dxd, BPPARAM = MulticoreParam(workers = 10))
# save(dxd, file = 'RData/dxd_undif.RData')
# plotDispEsts(dxd)
# dxd = testForDEU(dxd, BPPARAM = MulticoreParam(workers = 10))
# dxd = estimateExonFoldChanges(dxd, fitExpToVar = 'Treatment', 
#                               BPPARAM = MulticoreParam(workers = 10))
# save(dxd, file = 'RData/dxd_undif_deu.RData')
load('RData/dxd_undif_deu.RData')
res_orig = DEXSeqResults(dxd)

# Identify genes with significanly different (padj < 0.05) exon usage in at 
# least one exon
head(res_orig)
dim(res_orig)

# Remove the exons with insufficient data to analyze
res = (res_orig
       %>% data.frame()
       %>% filter(!is.na(padj)))
dim(res)

sum(res$padj < 0.05)
```

There are 1,520,722 exons analyzed. Of them, 1,125,713 had sufficient data for
analysis, and 6,520 had adjusted p-values less than 0.05.


Pull out the genes that have at least one DEU exon:

```{r}
sig_genes = (res
           %>% filter(padj < 0.05)
           %>% select(groupID)
           %>% unique())$groupID
length(sig_genes)

# Check if any of the problem genes have DEU
any(sig_genes %in% duplicate_geneIDs$gene_id)
```

989 genes have at least one exon with DEU. None of the genes with duplicate IDs 
have DEU.

#### Goseq

```{r}
all_genes = unique(res_orig$groupID)
length(all_genes)
genes = unique(res$groupID)
length(genes)
```

Of the 40840 genes in the data set, 19,028 had sufficient coverage for analysis
in at least one exon.

```{r}
# Make a binary vector of all genes, 1 for significant, 0 for non
deg_v = genes %in% sig_genes
deg_v = as.numeric(deg_v)
names(deg_v) = genes

# remove the duplicate genes
deg_v = deg_v[!(genes %in% duplicate_geneIDs$gene_id)]
names(deg_v) = gene_id_v[names(deg_v)]
head(deg_v)
any(is.na(names(deg_v)))

# Get the bias and length estimations for goseq
np = nullp(deg_v, 'mm39', 'refGene')

# Run goseq
gs = goseq(np, 'mm39', 'refGene')

head(gs)
dim(gs)
gs_fixed = (gs
            %>% mutate(padj = p.adjust(over_represented_pvalue, 'BH')))
head(gs_fixed)

# Count the significant categories
sum(sum(gs_fixed$padj < 0.05))
```

The 989 genes with significantly different exon usage produced 
over-representation of DEU in 220 GO categories (out of a total of 21,389 
possible categories, after BH FDR adjustment).


### Differentiated cells

#### DEXSeq

I run this once and then keep it stored because it takes a long time to run

```{r}
# # Run DEXSeq on differentiated samples
# head(exon_counts)

samdat_dif = filter(samdat, Differentiation == 'Diff')
exon_ct_dif = exon_counts[,rownames(samdat_dif)]
samdat_dif
head(exon_ct_dif)

# dxd = DEXSeqDataSet(exon_ct_dif, samdat_dif,
#                     design = ~sample + exon + exon:Treatment,
#                     featureID = annot$exon_unique,
#                     groupID = annot$GeneID)
# dxd = estimateSizeFactors(dxd, locfunc = genefilter::shorth)
# dxd = estimateDispersions(dxd, BPPARAM = MulticoreParam(workers = 10))
# save(dxd, file = 'RData/dxd_dif.RData')
# plotDispEsts(dxd)
# dxd = testForDEU(dxd, BPPARAM = MulticoreParam(workers = 10))
# dxd = estimateExonFoldChanges(dxd, fitExpToVar = 'Treatment',
#                               BPPARAM = MulticoreParam(workers = 10))
# save(dxd, file = 'RData/dxd_dif_deu.RData')
load('RData/dxd_dif_deu.RData')
res_orig = DEXSeqResults(dxd)

# Identify genes with significanly different (padj < 0.05) exon usage in at 
# least one exon
head(res_orig)
dim(res_orig)

# Remove the exons with insufficient data to analyze
res = (res_orig
       %>% data.frame()
       %>% filter(!is.na(padj)))
dim(res)

sum(res$padj < 0.05)
```

There are 1,520,722 exons analyzed. Of them, 1,125,713 had sufficient data for
analysis, and 6,520 had adjusted p-values less than 0.05.


Pull out the genes that have at least one DEU exon:

```{r}
sig_genes = (res
           %>% filter(padj < 0.05)
           %>% select(groupID)
           %>% unique())$groupID
length(sig_genes)

# Check if any of the problem genes have DEU
any(sig_genes %in% duplicate_geneIDs$gene_id)
```

219 genes have at least one exon with DEU. None of the genes with duplicate IDs 
have DEU.

#### Goseq

```{r}
all_genes = unique(res_orig$groupID)
length(all_genes)
genes = unique(res$groupID)
length(genes)
```

Of the 40840 genes in the data set, 21,782 had sufficient coverage for analysis
in at least one exon.

```{r}
# Make a binary vector of all genes, 1 for significant, 0 for non
deg_v = genes %in% sig_genes
deg_v = as.numeric(deg_v)
names(deg_v) = genes

# remove the duplicate genes
deg_v = deg_v[!(genes %in% duplicate_geneIDs$gene_id)]
names(deg_v) = gene_id_v[names(deg_v)]
head(deg_v)
any(is.na(names(deg_v)))

# Get the bias and length estimations for goseq
np = nullp(deg_v, 'mm39', 'refGene')

# Run goseq
gs = goseq(np, 'mm39', 'refGene')

head(gs)
dim(gs)
gs_fixed = (gs
            %>% mutate(padj = p.adjust(over_represented_pvalue, 'BH')))
head(gs_fixed)

# Count the significant categories
sum(sum(gs_fixed$padj < 0.05))
```

The 219 genes with significantly different exon usage produced 
over-representation of DEU in 0 GO categories (out of a total of 21,389 
possible categories, after BH FDR adjustment).
